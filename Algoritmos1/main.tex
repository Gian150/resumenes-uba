\input{../document.setup}

\title{Algoritmos y Estructuras de Datos I}
\author{Gianfranco Zamboni}

\input{../page.setup}

\input{Macros/Algo1Macros}
\input{Macros/macros}

\begin{document}
	\maketitle
	\tableofcontents
	\newpage

	\red{ESTE RESUMEN NO ESTÁ TERMINADO. LA MATERIA CAMBIO TODA DESDE QUE LA CURSE, HAY COSAS EN LAS DIAPOS QUE NO TENGO IDEA QUE SON Y, LA VERDAD, PAJA LEERLOS.}
	\part{Especificación de programas utilizando contratos}
\section{Lógica propocisional}
La lógica propocisional es una \textbf{herramienta usada para escribir expresiones}/fórmulas que pueden representar dos posibles valores: Verdadero (V) ó Falso (F), a los que llamaremos valores de verdad.

\subsubsection*{Sintaxis}
Las \textbf{fórmulas son secuencias de símbolos ordenadas} de manera tal\textbf{ que respeten ciertas reglas}. El conjunto de símbolos y de variables que se pueden usar en las fórmulas junto con estas reglas forman la sintaxis del lenguaje (en este caso el lenguaje de la Lógica Proposicional).

\begin{itemize}
	\item Símbolos: \True, \False, $\lnot$, $\land$, $\lor$, $\Then$, $\Iff$, $($, $)$
	\item Variables proposicionales (son infinitas): Serán secuencias de una o más letras: $p$, $q$, $r$, $ss$,\dots
	\item Reglas:
	\begin{itemize}
		\item \True~ y \False~ son fórmulas.
		\item Cualquier variable proposicional es una fórmula.
		\item Si $A$ es una fórmula entonces $\lnot A$ es una fórmula.
		\item Si $A_1,A_2,\dots,A_n$ son fórmulas entonces $(A_1\land A_2 \land \dots\land A_n)$ es una fórmula.
		\item Si $A_1,A_2,\dots,A_n$ son fórmulas entonces $(A_1\lor A_2 \lor \dots\lor A_n)$ es una fórmula.
		\item Si $A$ y $B$ son fórmulas entonces $(A\Then B)$ es una fórmula.
		\item Si $A$ y $B$ son fórmulas entonces $(A\Iff B)$ es una fórmula.
	\end{itemize}
\end{itemize}

Si una secuencia de símbolos cumple con alguna de las reglas mencionadas, entonces diremos que es una \textbf{fórmula bien formada}.
\subsubsection*{Semántica clásica}
\textbf{La semántica} de un lenguaje, nos \textbf{permite asignarle un significado (valor) a las fórmulas bien formadas}. Como se mencionó al comienzo de esta sección, en la lógica proposicional, una fórmula podrá representar los valores ``verdadero" (V) y ``falso" (F).

Dada una fórmula, se podrá calcular su valor de verdad usando las siguientes reglas:
\begin{itemize}
	\item \True~ es verdadero
	\item \False~ es falso
	\item Las variables proposicionales podrán ser verdaderas o falsas dependiendo del contexto en el que se las use y que cosa representen, por ejemplo, si $p$ es el valor de verdad de la propocisión ``está lloviendo'' y, efectivamente, está lloviendo entonces $p$ es verdadero. Pero si $p$ significa esto y no está lloviendo, entonces $p$ es falso.
\end{itemize}

Sean $A$ y $B$ dos fórmulas con un valor de verdad conocido, entonces:

\begin{itemize}
	\item $\lnot A$ será la negación de $A$, es decir, si $A$ es verdadero, entonces $\lnot A$ y viceversa.
	\item $A \land B$ será la conjunción entre $A$ y $B$ y será verdadero si y solo si ambas fórmulas ($A$ y $B$) son verdaderas.
	\item $A \lor B$ será la disjunción entre $A$ y $B$ y será verdadero si alguna de las fórmulas lo es.
	\item $A \rightarrow B$ define una relación entre ambas fórmulas. Se lee ``$A$ implica $B$'' y será falso si y solo si $A$ es verdadero y $B$ es falso.
	\item $A \leftrightarrow B$ define una relación entre ambas fórmulas. Se lee ``$A$ si y solo si $B$'' y será verdadero si y solo si $A$ y $B$ tienen el mismo valor de verdad.
\end{itemize}

\begin{table}[h]
	\begin{center}
		\begin{tabular}{c|c|c|c|c|c|c}
			$p$ & $q$ & $\lnot p$ & $(p \land q)$ & $(p \lor q)$ & $(p \Then q)$ & $(p \Iff q)$  \\
			\hline
			V & V & F & V & V & V & V\\
			V & F & V & F & V & F & F\\
			F & V & - & F& V & V & F \\
			F & F & - & F & F & V & V\\
		\end{tabular}
	\end{center}
	\caption{Tabla de verdad para cada uno de los símbolos descriptos} 
\end{table}

\subsection{Tautologias, contradiciones y contigencias}

Diremos que una fórmula es una \textbf{tautologíasi siempre toma el valor $V$} para valores distintos de sus variables propocisionales. Por ejemplo, $((p\land q) \Then p)$ es una tautología, esto se puede mostrar usando una tabla de verdad:

\begin{table}[h]\label{table::PyQImpliesP}
	\begin{center}
		\begin{tabular}{c|c|c|c}
			$p$ & $q$ & $(p\land q)$ & $((p \land q)\Then p)$ \\
			\hline
			V & V & V & V \\
			V & F & F & V \\
			F & V & F & V \\
			F & F & F & V \\
		\end{tabular}
	\end{center}
	\caption{Tabla de verdad de  $((p\land q)\Then p)$} 
\end{table}

Una \textbf{contradicción será una fórmula que siempre toma el valor $F$} para valores definidos de sus variables proposicionales.

\begin{table}[h]
	\begin{center}
		\begin{tabular}{c|c|c}
			$p$ & $\lnot p$ & $(p\land \lnot q)$ \\
			\hline
			V & F & F \\
			F & V & F \\
		\end{tabular}
	\end{center}
	\caption{$(p\land \lnot p)$ es una contradicción} 
\end{table} 

Al resto de las fórmulas (las que nos son ni tautologías ni contradicciones) las llamaremos \textbf{contigencias}.

\subsubsection*{Equivalencias entre fórmulas}

Dadas dos preposiciones $p$ y $q$, las siguientes fórmulas son tautologías:
\begin{itemize}
	\begin{multicols}{2}
		\item Idempotencia \\
		$(p\land p) \Iff p$\\
		$(p\lor p) \Iff p$
		
		\item Asociatividad\\
		$(p\land q)\land r \Iff p \land (q\land r)$ \\
		$(p\lor q)\lor r \Iff p \lor (q\lor r)$
		
		\item Conmutatividad\\
		$(p\land q) \Iff (q\land p)$ \\
		$(p\lor q) \Iff (q\lor p)$
		
		\item Distributividad\\
		$p\land (q \lor r) \Iff (p \land q)\lor(p\land r)$ \\
		$p\lor (q \land r) \Iff (p \land q)\lor(p\land r)$ \\

	\item Reglas de Morgan \\
$\lnot(p\land q) \Iff \lnot p \lor \lnot q$ \\
$\lnot(p\lor q) \Iff \lnot p \land \lnot q$ \\
		
	\end{multicols}
	
\end{itemize}
Que estas fórmulas sean tautologias significa que si encontramos alguno de sus lados en una fórmula, entonces podremos remplazarlo por el otro sin cambiar el valor de la misma.
\subsubsection*{Relaciones de fuerza}
Decimos que $A$\textbf{ es más fuerte que$B$ cuando $(A\Then B)$ es una tautología} . Tambien decimos que $A$ \textbf{fuerza a} $B$ o que $B$ \textbf{es más debil que} $A$.

Por ejemplo:
\begin{itemize}
	\item $(p\land q)$ es más fuerte que $p$. Podemos ver en la tabla \ref{table::PyQImpliesP} que, efectivamente, $((p\land q)\Then p)$ es una tautología.
	\item \False~es la fórmula más fuerte ya que, si $A$ es una fórmula, entonces $(\False\Then A)$ siempre es verdadera, sin importar que fórmula es $A$.
	\item \True~es la más debil, es decir que $(A\Then\True)$ es una tatutología para toda fórmula $A$.
\end{itemize}
\subsection{Semántica  trivaluada secuencial}

\textbf{Toda expresión está bien definida en un estado si todas las proposiciones valen $T$ o $F$}. Sin embargo, existe la posibilidad de que haya expresiones que no estén bien definidas (por ejemplo, la expresión $x/y$ no está bien definida si $y = 0$). Por esta razón, necesitamos una lógica que nos permita describir este estado.

Para esto, introducimos el valor de verdad \textit{Indefinido} ($\bot$) y una nueva de forma de evaluar las expresiones: La evaluación \textbf{secuencial}.

En esta nueva lógica, los términos se evalúan de izquierda a derecha y la evaluación termina cuando se puede deducir el valor de verdad, aunque el resto esté indefinido.

\begin{table}[h]
	\begin{center}
		\begin{tabular}{c|c|c|c|c}
			$p$ & $q$ & $(p \yLuego q)$ & $(p \oLuego q)$ & $(p\implicaLuego q)$\\
			\hline
			V & V & V & V & V \\
			V & F & F & V & F \\
			F & V & F & V & V \\
			F & F & F & F & V \\
			T & $\bot$ & $\bot$ & V & $\bot$ \\
			F & $\bot$ & F & V & V\\
			$\bot$ & V & $\bot$ & $\bot$ & $\bot$ \\
			$\bot$ & F & $\bot$ & $\bot$ & $\bot$ \\
			$\bot$ & $\bot$ & $\bot$ & $\bot$ & $\bot$ \\
		\end{tabular}
	\end{center}
	\caption{Tablas de verdad para $\yLuego$, $\oLuego$ y $\implicaLuego$} 
\end{table}

\section{Tipos de datos}
Un \textbf{tipo de datos} es un \textbf{conjunto de valores} provisto de una serie de \textbf{operaciones} que involucran a esos valores.

Para hablar de un elemento de un tipo $T$ en nuestro lenguaje escribimos un \textbf{término} o \textbf{expresión} que pueden ser:
\begin{itemize}
	\item una variable de tipo $T$,
	\item una constante de tipo $T$,
	\item o una función (operación) aplicada a otros términos (del tipo $T$ o de otro tipo).
\end{itemize}

Todos los tipos que definamos van a tener un elemento distinguido que indicará la falta de un valor (indefinición) de una variable y lo notaremos: $\perp$ ó Indef.  A continuación se da una pequeña introducción los tipos básicos que vamos a usar durante el curso, para verlos más en detalles ver el apendice \ref{appendice::datos}.

\subsection{Tipos básicos}
\begin{itemize}
	\item Booleanos (\bool): \True, \False
	\item Enteros (\ent): $-2,-1,0,1,5$, etc
	\item Reales (\float): $0.0025 ,~1.34,~$etc
	\item Carácteres (\cha): 'a', 'b', 'c', '4', etc.
\end{itemize}

\subsubsection{Tipos enumerados}
Los tipos enumerados son tipos con una cantidad finita de elementos denotados por una constante. 
\begin{center}
	$\enum{\textit{Nombre}}{\textit{constantes}}$
\end{center}
Estos tipos están compuestos por un \textit{nombre} y una lista de \textit{constantes} (en mayúsculas) separadas por comas.
\paragraph{Ejemplo}
\begin{center}
	$\enum{Día}{LUN, MAR, MIER, JUE, VIE, SAB, DOM}$
\end{center}
\subsubsection{Tuplas}
Son uplas de uno o más elementos, cada una de cualquier tipo. El tipo de una upla es $T_0\times T_1\times\dots\times T_k$ donde $T_i$ ($i = 0\dots k$) corresponde al tipo del elemento en la $i$-ésima posición de la upla. Proporcionan la operación básica enésimo $(~\bullet~)_n$ que nos permite acceder a lá enésima componente de la tupla.

$$(1, \True, 1.5)$$
\subsection{Cuantificadores}
El lenguaje usado en la cátedra, además nos provee formas de predicar sobre los elementos de un tipo de datos. 

\begin{itemize}
	\item $(\forall x : T) P(x)$ es un término de tipo Bool que afirma que todos los elementos de tipo $T$ cumplen la propiedad $P$ y se lee `'Para todo $x$ de tipo $T$ se cumple $P(x)$'', es decir es equivalente a la siguiente f.
	
	Este  cuantificador se llama \textbf{universal} y \textit{generaliza la conjunción}, es decir que nos permite de escribir de manera concisa una concatenacion de conjunciones ($\land$).
	\item $(\exists x : T) P(x)$ es un término de tipo Bool que afirma que al menos un elemento de tipo $T$ cumplen la propiedad $P$ y se lee `'Existe al menos un $x$ de tipo $T$ que cumple $P(x)$''.
	
	Este cuantificador se llama \textbf{existencial} y \textit{generaliza la disyunción} ($\lor$).
\end{itemize}

Como el uso de cuantificadores en una expresión  devuelve un valor booleano, se les puede aplicar operadores lógicos. En el caso de la negación, el $\forall$ se convierte en un $\exists$ y viceversa.


\paragraph{Variables libres y ligadas:}

Veamos la siguiente  expresión $y \land (\forall x : \ent) P(x)$. En está expresión, $x$ está \textbf{ligada} al cuantificador e $y$ se encuentra \textbf{libre}, es decir no hay ningún cuantificador que haga referencia a ella.

\subsection{Secuencias}
Una secuencia son varios \textbf{elementos del mismo tipo} $T$, posiblemente repetidos, ubicados en un cierto orden y diremos que son de tipo $\TLista{T}$ y $T$ puede ser cualquier tipo, incluso otra secuencia.

$$[1,2,3,4,5,7] \text{ es una secuencia de } \ent$$

Además, en todos los tipos de secuencias existe una secuencia especial, la \textbf{secuencia vacía}, que notaremos \lvacia.

Además, hay secuencias de ciertos tipos que tienen nombres especiales y que podremos usar en vez del tipo explicito, por ejemplo, las secuencias de carácteres son \textbf{Strings} y las sequencias de sequencias son \textbf{matrices}.

$$\mathsf{String} = \TLista{\cha}$$
$$\mathsf{Mat}\langle T \rangle = \matriz{T}$$

\subsubsection{Sumatoria}
El lenguaje de espicifación provee formas de acumular resultados para los tipos númericos $\ent$ y $\float$. La sumatoria retorna la suma de todas las expresiones númericas $Expr(i)$  entre $from$ y $to$:

$$\sum_{i=from}^{to} Expr(i) = Expr(from) + Expr(from + 1) + \dots + Expr(to -1) + Expr(to)$$

$from$ y $to$ forman un rango finito de valores enteros de tal forma que $from < to$. Si esto no se cumple, entonces la sumatoria devuelve cero. Ademas, si alguno de los valores que se encuentra en este rango hace que la expresión se indefina, entonces toda la sumatoria se indefine.

En el siguiente ejemplo, se suman todos los valores que se encuentran en las posiciones pares de una secuencia:

$$\sum_{i=0}^{|s|-1}(\IfThenElse{\aedmod{i}{2} = 0}{s[i]}{0})$$

Muchas veces, querremos usar esta operación para contar elementos que cumplan alguna propiedad, en estos, podremos hacer el siguiente abuso de notación:

$$\#\{ i \in [from, to] : P(i)\} = \sum_{i=from}^{to}(\IfThenElse{P(i)}{1}{0})$$

\subsubsection{Productoria}
El término productoria retorna el producto de todas las expresiones $Expr(i)$ entre $from$ y $to$:

$$\prod_{i=from}^{to} Expr(i) = Expr(from) * Expr(from + 1) * \dots * Expr(to -1) * Expr(to)$$

A diferencia de la sumatoria, si $from \leq to $ no se cumple entonces devuelve $1$. Si alguna de las expresiones se indefine, entonces tambien lo hace toda la productoria.

\section{Especificación}
Una \textbf{especificación} es una descripción de un problema en un lenguaje formal. Es un contrato que nos proporciona las propiedades que deben cumplir los datos de entrada del problema y las propiedades que debe cumplir su solución. Y, a partir de ella, podremos diseñar \textbf{algoritmos} o \textbf{programas} que describirán la (o una) solución del problema y como obtenerla.

Si bien \textbf{especificación} y \textbf{algoritmo} tienen definiciones muy parecidas, una especificación nos dice \textbf{qué} queremos resolver sin decirnos como hacerlo mientras que el algoritmo nos da un método que nos indica \textbf{como} obtener la solución que buscamos.

Por ejemplo, supongamos que queremos multiplicar dos números. Entonces una especificación podría ser $c = a*b$ que, en lenguaje matemático nos indica que $c$ es el número que va dar como resultado la multiplicación de $a$ y $b$.

Un algoritmo para realizar esta multiplicación podría ser el que enseñan en las secundarias, o el usado por los mayas, o el de los egipcios. Hay infinitos algoritmos capaces de resolver correctamente este problema.


La especificación, además, nos permite verificar formalmente la correctitud de un algoritmo y pensar mejores casos de test para las aplicaciones que programemos.

\paragraph{Nota:} Otra pequeña diferencia a tener en cuenta, un algoritmo y un programa \textbf{tampoco son lo mismo}. Un algoritmo es una secuencia de pasos que describe como resolver un problema, esta secuencia puede estar escrita en cualquier lenguaje (ingles, español, chino mandarin, C++, Python, etc), los programas son algoritmos escritos especificamente en un lenguaje entendible por la computadora.

\subsection{Partes de la especificación}
En algoritmos 1, una especificación tiene la siguiente forma:
\begin{center}
     \begin{minipage}[]{0.8\textwidth}
     \begin{proc}{\textit{nombre}}{\textit{parámetros}}{T}
     \pre{~\textit{P}~}
     \post{~\textit{Q}~}
	\end{proc}
  \end{minipage}
\end{center}

donde \textit{nombre} es el nombre que le damos al problema,  $P$ y $Q$ son dos predicados denominados la \textbf{precondición} y la \textbf{postcondición} del procedimiento y \textit{parámetros} es una lista de parámetros separada por comas.

\paragraph{Contrato:} El programador escribe un programa $P$ tal que el usuario suministra datos que hacen verdadera la precondición, entonces $P$ termina en una cantidad finita de pasos retornando un valor que hace verdadera la postcondición.

\vspace*{5mm}
Diremos que $P$ es \textbf{correcto} para la especificación dada por esa precondición y esa postcondición cuando se cumpla el contrato. 

En otras palabras, la especificación nos da las restricciones que las variables de entrada deben respetar para gantarizar una correcta solución al problema y, la poscondición, es la condición que debe cumplir el resultado de un algoritmo para que sea considerada una solución correcta.
 
Cuando el usuario no cumpla con la precondición establecida por la espificación el programa fallará. En este caso, es el usuario el que está faltando a su parte del contrato. En cambio, si el usuario respeta la precondición y el programa falla entonces $P$ no es correcto y sus resultados no pueden ser considerados soluciones al problema propuesto.

\subsubsection{Parámetros}

Cada parámetro del problema tiene la siguiente forma:
\begin{center}
	\textit{tipo\_pasaje} \textit{nombre}~:~\textit{tipo\_dato}
\end{center}

\paragraph{Tipos de pasaje} 
\begin{itemize}
	\item \textbf{Parámetros de entrada (in)}: Se utiliza una copia del parámetro durante la ejecución, quedando el valor original intacto.
	\item \textbf{Parámetros de salida (out)}: Son parámetros que no se inicializan (no contienen ningún valor al principio de la ejecución). Recién al finalizar, se copia un valor al mismo.
	\item \textbf{Parámetros de entrada-salida (inout)}: Son parámetros que funcionan como de entrada (se copia el valor del argumento al inicio) y como de salida (se copia el valor de la viarble al final) simultaneamente. El efecto final es que la ejecución del procedimiento \textbf{modifica} el valor del parámetro.
\end{itemize}
Cuando usamos parámetros de entrada-salida, tendremos \textbf{metavariables} que nos permitirán indicar los valores de ese parámetro en distintos puntos de la ejecución. En el siguiente ejemplo, usaremos la metavariable $a_0$ para referirnos al valor inicial del parámetro $a$:

\begin{center}
	\begin{minipage}[]{0.8\textwidth}
		\begin{proc}{incrementarEnUno}{\Inout $a$ : \ent}{}
			\pre{a_0 = a}
			\post{a = a_0 + 1}
		\end{proc}
	\end{minipage}
\end{center}

\subsubsection{Errores comunes}
Al momento de escribir una especificación podemos cometer dos tipos de errores que afectarán de una manera u otra al contrato:

\begin{itemize}
	\item \textbf{Sobre-especificación:} Ocurre cuando damos una \textbf{postcondición más restrictiva} de lo que se necesita, o bien una \textbf{precondición mas laxa}. Limita los posibles algoritmos que resuelven el problema porque impone más condiciones para la salida, o amplía los datos de entrada.
	\item\textbf{Sub-especificación:} Ocurre cuando damos una \textbf{precondición más restrictiva} de lo que se necesita, o bien una \textbf{postcondición mas debil}. Deja afuera datos de entrada o ignora condiciones necesarias para la salida (es decir, permite soluciones no deseadas).
\end{itemize}

\subsection{Funciones y predicados auxiliares}
Las funciones y los predicados auxiliares son expresiones del lenguaje a las que se les asigna un nombre. Permiten \textbf{modularizar} la  escritura de las especificaciones y facilita su lectura. Tienen la siguiente forma:

\begin{center}
	\auxilc{f}{argumentos}{tipo}{expresion}
	
	\pred{p}{argumentos}{formula}
\end{center}

Donde $f$ y $p$ son los nombres asignados que podrán usarse en el resto de le especificación en lugar de la \textit{expresion}/\textit{formula}. Los argumentos son opcionales y se reemplazan en la \textit{expresion}/\textit{formula} cada vez que se usa $f$/$p$.

Se debe tener en cuenta que las funciones auxiliares son solo un \textbf{remplazo sintáctico} dentro de una especificación, por lo que no se permiten definiciones recursivas. Además, no se permite usar una especificación dentro de otra, ya que las mismas no pertenecen  la lógica de primer orden.

Para que quede más claro, veamos dos ejemplos, el primero es una función auxiliar que nos permite sumar dos números reales. El segundo un predicado que devuelve true si y solo el entero pasado por parámetro es primo:
\begin{center}
\auxilc{suma}{ x, y : \float}{\float}{x+y}

\pred{esPrimo}{x : \ent}{(\forall~ y : \ent)~(1 < y < x)~\land~ (\aedmod{x}{y} \neq 0)}
\end{center}

\subsubsection{Expresiones condicionales}
Las expresiones condicionales, son expresiones cuyo valor depende del valor de verdad de una formula lógica (\textit{guarda}). 
Un ejemplo, es la función auxiliar $\mathsf{IfThenELse}$ que toma como argumentos un elemento $e$ de tipo \bool~ y dos valores $s$ y $r$ de tipo $T$. Si $e$ es \True, entonces, esta función, retorna $s$, si no, retorna $r$. Se podrá usar esta función de la siguientes formas:

$$a = \mathsf{IfThenElse}<T>(exp, s, r)$$
$$a = \IfThenElse{exp}{s}{r}$$

\subsection{Funciones auxiliares imprescindibles}
\paragraph{Cantidad de apariciones:}
Cuenta la cantidad de aparciiones de un elemento $e$ en la secuencia $s$.

\aux{\#apariciones}{s:~\TLista{T}, e:~$T$}{\ent}{\sum_{i=0}^{|s|-1}(\IfThenElse{s[i] = 0}{1}{0})}

\paragraph{Es permutación:} Devuelve verdadero si y solo si una secuencia es permutación de otra.

\pred{es\_permutacion}{s1, s2~:~\TLista{T}}{(\forall x~:~T)}

\subsection{Notas sobre la especificación de problemas}
\paragraph{Nombres de predicados y funciones:} Deben ser lo más declarativos posibles, es decir, deben describir el significado de lo que devuelven, ya que la idea es que nos permitan realizar especificaciones más concisas.

\paragraph{Comentarios:} Muchas veces, puede resultar dificil separar los predicados de las postcondicion o precondiciones en funciones o predicados auxiliares. En estos casos, se pueden agregar comentarios en castellano que aclaren lo que indica cada parte del predicado.

\begin{center}
	\begin{minipage}[]{0.8\textwidth}
		\begin{proc}{menorElemDistinos}{\In $s$ : \TLista{\ent}, out result : \ent}{}
			\pre{ \texttt{noNegativos}(s)~\land~\texttt{noHayRepetidos}(s)}
			\post{\\ 
				\comentario{\text{result es un indice válido de s}} \\
				0 \leq result < |s| ~ \land_L \\
				\comentario{\text{s[result] es el menor elemento de s}} \\
				(\forall i ~:~\ent((0\leq i < |s|) \implica_L s[result] \leq s[i]))
			\\}
		\end{proc}
	\end{minipage}
\end{center}

\section{Temario}
\begin{itemize}
	\item{Conceptos básicos de los programas imperativos}
	\item{Estructuras de control}
	\begin{itemize}
		\item Variables
	\end{itemize}
	\item{Ciclos}
	\begin{itemize}
		\item{Construcción}
		\item{Terminación}
		\item{Corrección}
	\end{itemize}
	\item{Corrección de programas}
	\begin{itemize}
		\item{Tipos}
		\item{Tratamientos de secuencias}
		\item{Fundamentos de ordenamiento}
		\item{Fundamentos de testing} 
	\end{itemize}
\end{itemize}

\newpage
\appendix
\part*{Apéndices}
\section{Tipos de Datos y sus funciones}\label{appendice::datos}
\subsection{Enteros}
\paragraph{Conjunto base:} Números enteros
\paragraph{Constantes:} 0; 1; -1; 2; -2; ...
\subsubsection*{Operaciones aritméticas:}


\begin{tabular}{clrp{6cm}}
	\textbf{Operación} & \textbf{Descripción} & \textbf{Entrada} & \textbf{Salida} \\
	$a+b$ &  Suma & $a, b \in \ent$ & $c\in\ent b$\\
	$a-b$ &  Resta & $a, b \in \ent$ & $c\in\ent$\\
	$a*b$ &  Multiplicación & $a, b \in \ent$ & $c\in\ent$ \\
	\abs{a} & Valor Absoluto & $a\in\ent$ & $c\in\ent$  \\
	\entdiv{a}{b} & División entera & $a, b \in \ent$ & $c\in\ent~:~a = c*b + r$ con $r \in\ent \land 0 < r < b$\\
	$\aedmod{a}{b}$ & Resto de dividir $a$ por $b$ & $a, b \in \ent$ & $r\in\ent~:~0 < r < b~\land~a = c*b + r$ con $c\in\ent_{> 0}$\\
	$a/b$ & División & $a, b \in \ent$ & $c\in\float~:~a = c*b$\\
\end{tabular}

\subsubsection*{Formulas de comparación:}
\begin{tabular}{cl}
	\textbf{Formula} & \textbf{Descripción} \\
	$a<b$ &  Menor \\
	$a\leq b$ &  Menor o igual\\
	$a > b$ &  Mayor \\
	$a \geq b$ & Mayor o igual \\
	$a = b$ & Igual\\
	$a \neq b$ & Distinto \\
\end{tabular}

\subsection{Reales}
\paragraph{Conjunto base:} Números reales
\paragraph{Constantes:} 0; 1; -7; 81.455; $\pi$; ...
\subsubsection*{Operaciones aritméticas:}
\begin{tabular}{clrl}
	\textbf{Operación} & \textbf{Descripción} & \textbf{Entrada} & \textbf{Salida} \\
	$a+b$ &  Suma & $a, b \in \float$ & $c\in\float$\\
	$a-b$ &  Resta & $a, b \in \float$ & $c\in\float$\\
	$a*b$ &  Multiplicación & $a, b \in \float$ & $c\in\float$ \\
	\abs{a} & Valor Absoluto & $a\in\float$ & $c\in\float$  \\
	$a/b$ & División & $a, b \in \float$ & $c\in\float$\\
	$\log{b}{a}$ & Logaritmo de $a$ en base $b$ & $a, b \in \float$ & $c\in\float~:~a = b^c$\\
	$\sin{b}$ & Seno & $a \in \float$ & $c\in\float$\\
	$\cos{b}$ & Coseno & $a \in \float$ & $c\in\float$\\
	$\tan{b}$ & Tangente & $a \in \float$ & $c\in\float$\\
	$\cot{b}$ & Cotangente & $a \in \float$ & $c\in\float$\\
	$\sec{b}$ & Secante & $a \in \float$ & $c\in\float$\\
	$\csec{b}$ & Cosecante & $a \in \float$ & $c\in\float$\\
\end{tabular}

\subsubsection*{Formulas de comparación:}
\begin{tabular}{cl}
	\textbf{Formula} & \textbf{Descripción} \\
	$a<b$ &  Menor \\
	$a\leq b$ &  Menor o igual\\
	$a > b$ &  Mayor \\
	$a \geq b$ & Mayor o igual \\
	$a = b$ & Igual\\
	$a \neq b$ & Distinto \\
\end{tabular}

\subsection{Booleanos}

\paragraph{Conjunto base:} $\{\textbf{true},~ \textbf{false}\}$

\paragraph{Constantes:} \texttt{true}, \texttt{false}

\subsubsection*{Operaciones (Conectivos lógicos)}
\begin{tabular}{clrl}
	\textbf{Operación} & \textbf{Descripción} & \textbf{Entrada} & \textbf{Salida} \\
	$!a$ &  Negación & $a\in \bool$ & $c\in\bool~:~c = \lnot a$\\
	$a~\&\&~b$ &  Conjunción & $a, b \in \bool$ & $c\in\bool~:~c = a \land b$\\
	$a~||~b$ &  Disjunción & $a, b \in \bool$ & $c\in\bool~:~c = a \lor b$ \\
\end{tabular}

\subsubsection*{Formulas de comparación:}
\begin{tabular}{cl}
	\textbf{Formula} & \textbf{Descripción} \\
	$a = b$ & Igual\\
	$a \neq b$ & Distinto \\
\end{tabular}

\subsection{Carácteres}

\paragraph{Conjunto base:} Letras, dígitos y símbolos.

\paragraph{Constantes:} 'a', 'b', 'c',\dots,'z','A','B','C',\dots, 'Z',\dots,'0','1',\dots,'9' (en el orden dado por el estándar ASCII)

\subsubsection*{Operaciones:}
\begin{tabular}{cp{6cm}rl}
	\textbf{Operación} & \textbf{Descripción} & \textbf{Entrada} & \textbf{Salida} \\
	$\ord{a}$ &  Numero los carácteres según el orden dado por el estándar ASCII & $a \in \cha$ & $c\in\ent_{\geq0}$\\
	$\tochar{a}$ &  Inversa de \ord{} & $a \in \ent_{\geq 0}$ & $c\in\cha~:~ a = \ord{c}$\\
\end{tabular}

\subsubsection*{Formulas de comparación:}
La comparación entre caracteres son comparaciones entre sus órdenes, de modo que $a \bullet b$ es equivalente a $\ord{a}\bullet\ord{b}$.

\vspace*{2mm}
\begin{tabular}{cl}
	\textbf{Formula} & \textbf{Descripción} \\
	$a<b$ &  Menor \\
	$a\leq b$ &  Menor o igual\\
	$a > b$ &  Mayor \\
	$a \geq b$ & Mayor o igual \\
	$a = b$ & Igual\\
	$a \neq b$ & Distinto \\
\end{tabular}
\subsection{Tipos enumerados}
\paragraph{Conjunto base:} Conjuntos finitos de constantes
\paragraph{Forma:}
\begin{center}
	$\enum{\textit{Nombre}}{\textit{constantes}}$    
\end{center}
\begin{itemize}
	\item \textit{Nombre}: con el que se va a designar al tipo del conjunto.
	\item \textit{constantes}: Lista de elementos del conjunto separados por coma.
\end{itemize}

\subsubsection*{Operaciones:}
\begin{tabular}{cp{6cm}rl}
	\textbf{Operación} & \textbf{Descripción} & \textbf{Entrada} & \textbf{Salida} \\
	$\ord{a}$ &  Da la posición del elemento en la definición del tipo & $a \in \cha$ & $c\in\ent_{\geq0}$\\
	$\texttt{nombre}(a)$ &  Inversa de \ord{}, "\texttt{nombre}" debe ser remplazado por el nombre del tipo & $a \in \ent_{\leq 0}$ & $c\in\cha~:~ a = \ord{c}$\\
\end{tabular}

\subsubsection*{Formulas de comparación:}
La comparación entre caracteres son comparaciones entre sus órdenes, de modo que $a \bullet b$ es equivalente a $\ord{a}\bullet\ord{b}$.

\vspace*{2mm}
\begin{tabular}{cl}
	\textbf{Formula} & \textbf{Descripción} \\
	$a<b$ &  Menor \\
	$a\leq b$ &  Menor o igual\\
	$a > b$ &  Mayor \\
	$a \geq b$ & Mayor o igual \\
	$a = b$ & Igual\\
	$a \neq b$ & Distinto \\
\end{tabular}

\subsection{Tuplas (Conjunto de tipos)}
\paragraph{Conjunto base:} Conjuntos finitos ordenados de elementos.
\paragraph{Tipos:} $T_1\times\dots\times T_n$.
\paragraph{Forma:}
\begin{center}
	$( e_1,\dots,e_n)$
\end{center}
\begin{itemize}
	\item $e_i$: Elemento de tipo $T_i$.
\end{itemize}

\subsubsection*{Operaciones:}
\begin{tabular}{cp{6cm}rl}
	\textbf{Operación} & \textbf{Descripción} & \textbf{Entrada} & \textbf{Salida} \\
	$( e_1,\dots,e_n)_n$ &  nésimo, es el elemento que se encuentra en la posición & $c\in\ent_{\geq0}$ & $e_n$\\
\end{tabular}

\subsection{Secuencia}
\paragraph{Conjunto base:} Elementos de un tipo $T$, posiblemente repetidos, ordenados de una manera específica.

\paragraph{Tipos:} $\TLista{T}$.
\paragraph{Forma:}
\begin{center}
	$[ e_1,\dots,e_n ]	$
\end{center}
\begin{itemize}
	\item $e_i$: Elemento de tipo $T$.
\end{itemize}

\subsubsection*{Operaciones:}
\begin{tabular}{cp{6cm}rll}
	\textbf{Operación} & \textbf{Descripción} & \textbf{Entrada} & \textbf{Salida} & \textbf{Precondición}\\
	$\longitud{a}$ &  Longitud de la secuencia $a$ & $a\in\TLista{T}$ & $n \in \ent$\\
	$a[i]$ & Elemento en la $i$-esima posición de $a$ & $a\in\TLista{T},~i\in\ent$ & $e_i \in T$ \\
	$\cab{a}$ & Primer elemento de la sequencia & $a\in\TLista{T}$ & $e\in T$ & $\longitud{a} > 0$ \\
	$\cola{a}$ & Elimina el primer elemento & $a\in\TLista{T}$ & $b\in \TLista{T}$ & $\longitud{a} > 0$ \\
	$\cons{t,a}$ & Agrega un elemento al principio & $t\in T, ~a\in\TLista{T}$ & $b\in \TLista{T}$ &  \\
	$a ++ b$ & Secuencia con los elementos de $a$ seguidos de $b$ & $a,b\in\TLista{T}$ & $b\in \TLista{T}$ & \\
	$\sub{a,d,h}$ & Elementos de la secuencia $a$ entre las posiciones $d$ y $h$ & $a\in\TLista{T}, d,h\in\ent$ & $b\in \TLista{T}$ & $0\leq d \leq h \leq |a|$ \\
	$\mathsf{setAt}(a,i,val)$ & La misma secuencia pero con el valor $val$ en la posición $i$ & $a\in\TLista{T}, d\in\ent,h\in\ent$ & $b\in \TLista{T}$ & \\
\end{tabular}

\subsubsection*{Formulas de comparación:}
La comparación entre secuencias involucra la comparación de sus elementos uno a uno. Si los elementos de dos secuencias son los mismos y se encuentran en el mimos orden, entonces son iguales.

\vspace*{2mm}
\begin{tabular}{cl}
	\textbf{Formula} & \textbf{Descripción} \\
	$a = b$ & Igual\\
\end{tabular}

\end{document}