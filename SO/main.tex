\input{../document.setup}

\input{custom.commands.tex}
\title{Sistemas Operativos - Apuntes para final}
\author{Gianfranco Zamboni}

\input{../page.setup}
\begin{document}
	\maketitle
	\tableofcontents
	
\newpage
\section{Introducción}
Un sistema informático tiene cuatro componentes:

\begin{itemize}
	\item El hardware (CPU, memoría y dispositivos de entrada salida) proveen los recursos básicos del sistema.
	\item Las aplicaciones definen la forma en que estos recursos va a ser usados para resolver los problemas del usuario.
	\item El sistema operativo controla el hardware y coordina su uso entre las distintas aplicaciones de los usuarios.
\end{itemize}

\subsection{El sistema operativo}
Un sistema operativo provee un entorno de ejecución de programas. Para esto tiene ciertos componentes que difieren de sistema en sistema pero que entre lo más comunes se encuentran:

\begin{itemize}
	\item \textbf{Drivers:} Programas manejan los detalles de bajo nivel relacionados con la operación de los distintos dispositivos.
	\item \textbf{Núcleo}: (o Kernel) Es el sistema operativo, propiamente dicho. Se encarga de las tareas fundamentales y contiene los diversos sub-sistemas que iremos viendo a lo largo de la materia.
	\item\textbf{Sistema de archivos}: Forma de organizar los datos en el disco para gestionar su acceso, permisos, etc.
	\begin{itemize}
			\item \textbf{Archivo:} Secuencia de bits con un nombre y una serie de atributos que indican permisos.
			\begin{itemize}
				\item\textbf{Binario del sistema}: Son archivos que no forman parte del kernel pero suelen llevar a cabo tareas muy importantes o proveer las utilidades básicas del sistema.
				\item \textbf{Archivos de configuración:} Son archivos especiales con información que el sistema operativo necesita para funcionar.
			\end{itemize}

		\item \textbf{Directorio}: Colección de archivos y directorios que contiene un nombre y se organiza jerárquicamente.
		\begin{itemize}
			\item\textbf{Directorios del sistema}: Son directorios donde el propio SO guarda archivos que necesita para su funcionamiento.
		\end{itemize}
		\item \textbf{Dispositivo virtual}: Abstracción de un dispositivo físico bajo la forma, en general, de un archivo de manera tal que se pueda abrir, leer, escribir, etc.

		\item \textbf{Usuario}: La representación, dentro del propio Sistema Operativo, de las personas qo entidades que pueden usarlo. Sirve principalmente como una forma de aislar información entre distintos usuarios reales y de establecer limitaciones.

		\item \textbf{Grupo}: Una colección de usuarios
	\end{itemize}
\end{itemize}

\paragraph{Systems calls (Syscalls):} Son rutinas que proveen una interfaz a los servicios disponibles en el sistema. Generalmente, son rutinas escritas en C/C++ y llamarlas implican un cambio de contexto y privilegios del proceso a ser ejecutado. Algunos de estos servicios son:
\begin{itemize}
	\item Creación y control de procesos.
	\item Pipes.
	\item Señales
	\item Operaciones de archivos y directorios
	\item Excepciones
	\item Errores del bus
	\item Biblioteca C
\end{itemize}

\section{Procesos y API}

\paragraph{Proceso:} Es un programa en ejecución y todas las estructuras que debe mantener el sistema para su correcto funcionamiento. Entre ellas, los valores de los registros, el program counter, el stack del proceso, el área de memoria en la que se cargan las instrucciónes a  ejecutar (el programa propiamente dicho) y el área de datos (contiene variables globales) y un heap de memoria (que es donde reserva memoria dinámica).

\subsection{Creación y control de un proceso}
\subsubsection{Creación de un proceso}

Durante su ejecución, un proceso puede crear nuevos procesos. En este caso llamamos \textbf{proceso padre} al proceso que crea nuevos procesos y \textbf{procesos hijos} a los procesos creados. Además, cada proceso hijo podrá crear otros procesos, formando así un \textbf{árbol} de procesos.

En la mayoría de los sistemas operativos, se asigna a cada proceso un identificador numérico único llamado \textbf{process id} o \textbf{pid} que sirve como índice para poder acceder a varios de sus atributos.

El nuevo proceso hijo creado necesitara de ciertos recursos para poder llevar a cabo su objetivo. Estos recursos podrán ser obtenidos directamente del sistema operativo o estar restringidos a los recursos del proceso padre.

Cuando un proceso crea un nuevo proceso (\texttt{fork()}) hay dos posibilidades:

\begin{itemize}
	\item El padre y su hijo continúan ejecutando concurrentemente.
	\item El padre espera a que alguno o todos sus hijos terminen para seguir ejecutando (\texttt{wait()}).
\end{itemize}

Además, el nuevo proceso puede ser un duplicado de su padre o cargar un nuevo programa (\texttt{exec()})

\begin{center}
	\includegraphics[width=0.9\textwidth]{imagenes/process_creation.png}
	\end{center}

\subsubsection{Terminación}
Un proceso termina cuando ejecuta su última instrucción y pide al sistema operativo que lo borre usando la syscall \texttt{exit()}. En este momento, el proceso envía el código de estado con el que terminó a su padre y el sistema operativo libera todo los recursos que le había asignado.

La terminación puede ocurrir por varios motivos. Un proceso puede causar la terminación de otro usando las syscalls adecuadas (usualmente, esto puede hacerlo solo el proceso padre).

\subsubsection{Un poco más sobre las syscalls mencionadas}
\begin{itemize}
	\item \texttt{pid\_t fork()}: Crea un nuevo proceso. En el caso del creador se retorna el PID del hijo. En el caso del hijo, retorna 0.
	\item \texttt{int\ execve(const char* filename, char* const argv[], char* const envp[] )}: \\ Sustituye la imagen de memoria del programa por la del programa ubicado en filename.
	\item \texttt{pid\_t forkv()}: Crea un hijo sin copiar la memoria del padre, el hijo tiene que hacer \texttt{exec}.

	Un proceso creado con esta syscall comienza con sus páginas de memoria apuntando a las mismas que las de su padre. Recién cuando alguno escriba en memoria, se hace la copia. Esto se llama \textbf{Copy-On-Write}.

	\item \texttt{pid\_t wait(int* status)}: Bloquea al padre hasta que algún hijo termine o hasta que alcance el status indicado.
	\item \texttt{pid\_t waitpid(pid\_t pid, int* status)}: Igual al anterior pero espera a que el hijo con PID \texttt{pid} llegue a ese status.
	\item \texttt{void exit(int status)}: Finaliza el proceso actual.
	\item \texttt{clone(...)}: Crea un nuevo proceso. El hijo comparte parte del contexto con el padre. Es usado en la implementación de threads.
\end{itemize}

\paragraph{Fork Bomb:} Un proceso crea infinitos hijos.
\subsection{Estados de un proceso}
Durante su ejecución, un proceso va modificando su estado acorde al siguiente diagrama:

\begin{center}
	\vspace*{0.5cm}
	\includegraphics[width=0.9\textwidth]{imagenes/estados-proceso.png}
\end{center}

\begin{itemize}
	\item \textbf{Nuevo (New):} El proceso se está creando.
	\item \textbf{Listo (Ready):} El proceso está listo para ser ejecutado.
	\item \textbf{Bloqueado (Waiting):} El proceso está esperando a que ocurra algo (por ejemplo a que se complete una operación de entrada salida)
	\item \textbf{Ejecutando (Running):} El proceso se está ejecutando.
	\item \textbf{Terminado (Terminated):} El procesó termino de ejecutarse.
\end{itemize}

Es importante notar que solo un proceso puede estar \textbf{ejecutando} en un instante de tiempo de dado. Sin embargo, muchos procesos pueden estar bloqueados o listos simultáneamente.

\subsection{Process Control Block (PCB)}
Cada proceso está representado, en el sistema operativo, por un Process Control Block o Task Control Block. El mismo contiene información asociada a cada proceso, entre ellas:
\begin{itemize}
	\item El estado del proceso
	\item El program counter (la dirección de memoría de la próxima instrucción a ser ejecutada)
	\item Los registros del CPU,
	\item Información de Scheduling, como puede ser prioridad de ejecución
	\item Información de manejo de memoria, como las direcciones de los directorios de paginas o las tablas de segmentación.
	\item Estadísticas de uso del sistema
	\item Información de E/S (que dispositivos está usando, lista de archivos abiertos, etc)
\end{itemize}

\subsection{Scheduler}
\paragraph{Multiprocesador:} Un equipo con más de un procesador.
\paragraph{Multiprogramación:} La capacidad de un SO de tener varios procesos en ejecución.
\paragraph{Multiprocesamiento:} Se refiere al tipo de procesamiento que sucede en los multiprocesadores.
\paragraph{Multitarea:} Es una forma especial de multiprogramación, donde la conmutación entre procesos se hace de manera tan rápida que da la sensación de que varios programas están corriendo en simultáneo.
\paragraph{Multithreaded:} Son procesos en los cuales hay varios \textit{mini procesos} corriendo en paralelo (de manera real o ficticia).

\subsubsection{Context Switching}
Una interrupción hace que el sistema operativo cambie la tarea de una CPU y corra un rutina del kernel. Cuando esto ocurre, el sistema, debe guardar el \textbf{contexto} del proceso que se está ejecutando para poder retornar a la ejecución del mismo cuando termine de atenderla. Este contexto es el PCB del proceso.

\vspace*{0.5cm}
\begin{center}
	\includegraphics[width=0.625\textwidth]{imagenes/context-switch.png}

\end{center}

	\subsubsection{Colas de procesos}
Una de las características de los sistemas operativos actuales es que nos permiten correr varias aplicaciones a la vez, sin embargo solo un proceso puede estar ejecutando en la CPU. Para darnos la sensación de simultaneidad, el SO hace lo que se llama \textbf{preemption}.

\paragraph{Preemption:} A cada proceso le asigna un \textbf{quantum} o una cantidad de tiempo durante la cual es ejecutado. Una vez que transcurrido ese tiempo, se guarda el contexto del proceso en memoria y se carga el contexto del próximo proceso a ejecutar.

El objetivo de la multiprogramación es intercambiar las tareas que se ejecutan en la CPU lo suficientemente rápido como para que el usuario pueda interactuar con dada programa como si estuviesen ejecutándose simultáneamente.Para esto existe un proceso especial llamado \textbf{Scheduler} que selecciona el próximo proceso que debe ser ejecutado.

El mismo dispone de varias colas de procesos en los que se encuentran los PCB de los procesos en ejecución. Los PCB se van encolando y desencolando de cada cola dependiendo del estado de cada proceso.

\vspace*{0.5cm}
\begin{center}
	\includegraphics[width=0.8\textwidth]{imagenes/process_queues.png}
\end{center}

\subsection{Inter Process Communication (IPC)}
Los procesos que se están ejecutando concurrentemente en el sistema operativa pueden ser \textbf{procesos independientes} o \textbf{cooperativos}.

\paragraph{Procesos independiente:} Es un proceso que no puede afectar o ser afectado por otros procesos ejecuntandose en el sistema operativo.

\paragraph{Procesos cooperativos:} Son procesos que no son independientes (pueden afectar o ser afectados por otros procesos).

Los procesos cooperativos requieres de un mecanismo de comunicación que les permita intercambiar datos e información. Hay dos modelos fundamentales para hacer esto: \textbf{memoria compartida} y \textbf{Pasaje de mensajes}.

En el modelo de memoria compartida, se establece un área de memoría que es compartida entre procesos. Los procesos pueden intercambiar información leyendo y escribiendo en este área.

En el modelo de pasaje de mensajes, la comunicación se realiza a través de mensajes entre los procesos cooperativos.

\subsubsection{Pasaje de mensaje}
Los mensajes proveen a los procesos un mecanismo que permite que los procesos se comuniquen entre si y sincronicen sus acciones. Un sistema que permite el pasaje de mensajes provee al menos dos operaciones:
\begin{center}
	\texttt{send(message)}\hspace*{1cm}\texttt{receive(message)}
\end{center}

Los mensajes pueden tener una longitud fija o variable. La primera opción es más fácil de implementar pero hace que la programación de tareas sea mas tediosa. Los mensajes de longitud variable necesitan un sistema más complejo pero permite más agilidad a la hora de programar tareas.

Si un proceso $P$ y $Q$ se quieren comunicar, entonces debe existir un \textbf{link de comunicación} entre ellos. Para crear este link, se deben tener en cuenta el tipo de comunicación que se desea ofrecer:
\begin{itemize}
	\item \textbf{Direccionamiento}
	\begin{itemize}
		\item \textbf{Conexión directa:} Cada proceso debe explicitar el nombre del proceso destinatario/receptor:
		\begin{itemize}
			\item \texttt{send(P, message)} - Envía un mensaje al proceso $P$
			\item \texttt{receive(Q, message)} - Recibe un mensaje del proceso $Q$
		\end{itemize}

		En este caso, el link de comunicación se establece automáticamente entre cada par de procesos que quiere comunicarse. Y cada proceso sabe la identidad del otro.

		\item \textbf{Comunicación indirecta:} Los mensajes son enviados a buzones (\textbf{mailboxes}) o puertos (\textbf{puertos}). Cada buzón tiene un identificador único. Un proceso puede comunicarse con otro a través de varios buzones.
		\begin{itemize}
			\item \texttt{send(A, message)} - Envía un mensaje al buzón $A$
			\item \texttt{receive(A, message)} - Recibe un mensaje del buzón $A$
		\end{itemize}

		En este esquema, un link se establece entre dos procesos solo si comparten un buzón. Además un link puede estar asociado a varios pares de procesos e incluso puede haber varios links entre dos mismos procesos.

	\end{itemize}
	\item \textbf{Sincronización:} El pasaje de mensajes puede ser bloqueante (síncrono) o no bloqueante (asíncrono):
	\begin{itemize}
		\item \textbf{Envío bloqueante:} El proceso que envía un mensaje espera a que el mismo sea recibido por su destinatario.
		\item \textbf{Envío no bloqueante:} El proceso envía el mensaje y sigue su ejecución.
		\item \textbf{Recepción bloqueante:} El proceso se bloquea hasta que recibe un mensaje.
		\item\textbf{Recepción no bloqueante:} El receptor recibe un mensaje válido o null.
	\end{itemize}
	\item Buffering: Los mensajes intercambiados entre procesos deben almacenarse en una cola temporal. Estas colas pueden ser de tres tipo:
	\begin{itemize}
		\item\textbf{Capacidad Cero:} El link no puede tener mensajes en espera. El remitente debe bloquearse hasta que el mensaje sea recibido.
		\item \textbf{Capacidad acotada:} La cola tiene una capacidad finita $n$ por lo que puede haber a lo sumo $n$ en espera. Si la cola no está llena se puede enviar un mensaje, sino el remitente debe bloquearse hasta que se que haya espacio disponible.
		\item \textbf{Capacidad infinita:} El remitente nunca se bloquea.
	\end{itemize}
\end{itemize}

\subsubsection{Sockets}
Los sockets son los extremos de una comunicación que usan dos procesos para comunicarse a través de una red. Cada socket está identificado por una dirección IP y un número de puerto. 	

En general, se usa una arquitecutra cliente-servidor: El servidor espera a que un cliente haga un pedido y, una vez que lo recibe, acepta la conexión del socket del cliente para completar la conexión. El número del socket del servidor, en general, va a ser menor o igual a 1024. Estos puerstos son los puertos conocidos (\textit{well known ports}) e implementan

Cuando el proceso cliente inicia la conexión, la computadora que lo está ejecutando le asigna un puerto arbitrario cuyo número es mayor a 1024.
\subsubsection{Pipes}
Un \textbf{pipe} es un canal que provee una de las formas más simples de comunicación entre dos procesos aunque tienen sus limitaciones. Al implementar un pite, se debe tener ciertas consideraciones: 
\begin{enumerate}
	\item ¿El pipe permite comunicación bidireccional o unidireccional?
	\item Si es bidireccional, es \textbf{half-duplex} (para mandar información se debe esperar a que el otro extremo del pipe termina de hacerlo) o \textbf{full-duplex} (la información puede viajar de un lado a otro y viceversa simultaneamente).
	\item ¿Debe existir alguna relación entre los procesos que se están comunicando (por ejemplo, padre-hijo)?
	\item ¿Los procesos se van a poder comunicar dentro de una red o tienen que estar en la misma maquina?
\end{enumerate}

\paragraph{Ordinary pipes:} Permiten que dos procesos se comuniquen en modo servidor-consumidor: El servidor escribe en un extremo del pipe (extremo de escritura) y el consumidor lee desde el otro extremo (extremo de lectura). Estos pipes son unidireccionales. Si se necesita una comunicación bidireccional se debe crear otro pipe que permita mandar datos en la otra dirección.

Este tipo de pipes requieren que los procesos que se comunican tengan una relación padre-hijo y dejan de existir una vez que la comunicación termina.

\paragraph{Named pipes:} Proveen comunicación bidireccional y no necesitan que los procesos estén relacionados. Una vez que es establecido, varios procesos pueden usarlo para comunicarse y continuan existiendo incluso después de que las comunicaciones hayan finalizado.

\subsection{E/S bloqueante / no bloqueante}
	Cundo un proceso necesita escribir o leer información de algún dispositivo necesita realizar operaciones de \textbf{entrada/salida}

	Estas operaciones son muy lentas por lo que quedarse bloqueado es un desperdicio de tiempo.

	\paragraph{Busy Waiting:} El proceso no hace nada pero no libera el CPU. Se gastan ciclos de procesamiento en hacer nada.

	Para evitar esto se utilizan algunas técnicas que permiten al SO operativo seguir ejecutando mientras espera la respuesta de los dispositivos:

	\begin{itemize}
		\item \textbf{Polling}: El proceso libera la CPU per todavía recibe un quantum que desperdicia hasta que la E/S esté terminada.
		\item \textbf{Interrupciones:} Esto permite la multiprogramación. El SO no le otorgá más quantum al proceso hasta que su E/S esté lista. El hardware comunica esto mediante una interrupción que hace que el proceso se despierte.
	\end{itemize}

	\subsection{Manejo básico de un shell Unix}
\subsubsection{File descriptors:}
	En Unix, cada proceso se crea con una tabla que le permite identificar cuales son los archivos que tiene abiertos. Cada índice es un \textbf{file descriptors} que usa el Kernel para saber como leer/escribir datos en los distintos archivos (en Unix, el teclado y la pantalla se modelan como archivos).
	
	Además, cada proceso hereda de su proceso padre tres archivos abiertos que ocupan los file descriptors 0, 1 y 3 y representan la entrada estándar (\textbf{stdin}), la salida estandar (\textbf{stdout}) y el error estandar (\textbf{stderr}), respectivamente.
	
	Linux provee de dos llamadas al sistema que nos permiten leer/escribir a un archivo usando su file descriptor \texttt{fd}:
	
	\begin{center}
		\texttt{ssize\_t read(int fd, void *buf, size\_t count)}

		\texttt{ssize\_t write(int fd, const void *buf, size\_t count);}
	\end{center}
	
Aquí \texttt{buf} es un puntero a donde se almacenan los datos a leer o escribir y \texttt{count} la cantidad de bytes que hay escribir/leer.

\subsubsection{Comandos de consola}
\begin{itemize}
	\item \texttt{echo} escribe lo que le pasemos como parámetro en su \textbf{stdout}.
	\begin{center}
		\texttt{echo ``Esto es un mensaj''}	\end{center}
	\item \texttt{>} Se le indica a la consola que el \textbf{stdout} se redirija a un archivo:
	\begin{center}
		\texttt{echo ``Esto es un mensaje'' > mensaje.txt}
	\end{center}
	\item \texttt{|} Redirige el \textbf{stdout} de un proceso hacia el \textbf{stdin} de otro:
	
	\begin{center}
		\texttt{echo ``Esto es un mensaje'' | wc -c}
	\end{center}

	En este caso, el primer proceso ejecuta el comando \texttt{echo} que imprime en \textbf{stdout} el mensaje \texttt{``Esto es un mensaje''}. El segundo proceso recibe por \textbf{stdin} lo que se escribió en el \textbf{stdout} del proceso que ejecutó \texttt{echo}
\end{itemize}
  
\newpage
	
\section{Scheduling} 
	En sistemas con un único procesados, solo se puede correr de a un proceso por vez. Uno de los objetivos de la multiprogramación es que todo el tiempo se esté ejecutando un proceso para maximizar el uso de CPU.
	
	Cada vez que el CPU entra en estado IDLE, el sistema debe seleccionar alguno de los procesos que estén listos para ser ejecutados. El proceso de selección es llevado a cabo por el \textbf{scheduler} usando la que se llama \textbf{cola de ejecución}.
	
	\subsection{Objetivos de la política de scheduling}
	Diferentes algoritmos de schedulling tienen diferentes propiedades y la elección de los mismos depende de las situación particular del sistema. Por lo general, un algoritmo de schedulling busca optimizar alguna combinación de las siguientes propiedades:
	
	\begin{itemize}
		\item \textbf{Eficiencia}: Maximizar la cantida de tiempo que el CPU esté ocupadp.
		\item \textbf{Rendimiento (Throughput)}: Maximizar el número de procesos terminados por unidad de tiempo.
		\item \textbf{Tiempo de ejecución (Turnaround time)}: Minimizar el tiempo total que le toma a un proceso ejecutar completamente (el intervalo de tiempo desde que el proceso se crea hasta que temina, incluye tiempo de esperas en la cola de procesos).
		\item \textbf{Ecuanimidad (F airness)}: Que Cada proceso reciba una dosis ``justa" de CPU (para alguna definición de justicia).
		\item \textbf{Carga del sistema (Waiting time)}: Minimizar la cantidad de tiempo que un proceso esté en la cola de espera.
		\item \textbf{Tiempo de respuesta (Response time)}: Minimizar el tiempo para que un proceso empieze a dar resultados.
		\item \textbf{Latencia}: Minimizar el tiempo requerido para que un proceso comienze a dar resultados.
		
		\item \textbf{Liberación de recursos:} Hacer que terminen cuanto antes los procesos que tiene reservados más recursos.
	\end{itemize}
	Muchos de estos objetivos son contradictorios. Si los usuarios del sistema son heterogéneos, pueden tener distintos intereses por lo que cada política de scheduling debe buscar maximizar una función objetivo que es una combinación de estas metas tratando de impactar lo menos posible en el resto.
	
	\subsection{Scheduling con y sin desalojo}
	
	El sistema puede tomar decisiones de scheduling en alguna de las siguientes situaciones:
	\begin{enumerate}
		\item Cuando un proceso pasa de estado \textit{Ejecutando} al estado de espera (por ejemplo cuando hace un request de entrada salida)
		\item Cuando pasa de \textit{Ejecutando} a \textit{Listo}
		\item Cuando pasa de \textit{Esparando} a \text{Listo}
		\item Cuando termina.
	\end{enumerate}

	\paragraph{Scheduling sin desalojo:} Se da cuando las decisiones de scheduling solo toman lugar en las situaciones $1$ y $4$, es decir se espera a que el proceso haya terminado o esté inactivo. Tiene como desventaja que si un proceso muy largo toma control del procesador se puede generar un cuello de botella.
	
	\paragraph{Scheduling sin desalojo:} Tambien conocido como \textbf{coperativo} o \textbf{nonpremptive}, se da cuando las decisiones de scheduling solo toman lugar en las situaciones $1$ y $4$, es decir se espera a que el proceso haya terminado o esté inactivo. Tiene como desventaja que si un proceso muy largo toma control del procesador se puede generar un cuello de botella y otros procesos mas cortos tardarían demasiado en ser ejecutados.
	
	\paragraph{Scheduling con desalojo:} Tambien llamado scheduling \textit{apropiativo} o \textit{preempitve}, se vale de la interrupción del clock para decidir si el proceso actual debe seguir ejecutando o le toca a otro. No da garantías de continuidad a los procesos.
	
	Por lo general se usa una combinación de los dos tipos de scheduling para decidir las políticas adecuadas.

	\subsection{Políticas de scheduling}
	\subsubsection{First In/First Out (FIFO)}
	El algoritmo FIFO (también conocido como First Come, First Served) es una de las políticas de scheduling más simples. Los process control block (PCB) se ubican en una cola, el próximo proceso a ejecutar es el que está en la cabeza. Cuando un proceso está listo para ser ejecutado se lo encola al final.
	
	Por un lado, es simple de implementar. Por otro, el tiempo de espera promedio de un proceso es bastante largo. Si llega un proceso que requiera mucho tiempo de CPU, tapona todos los demás, esto se llama \textbf{convoy effect}.
	
	\subsubsection{\red{Round Robin}}
	\subsubsection{\red{Multiples colas}}
	\subsubsection{Shortest Job First (SJF)}
	Este algoritmo asocia cada proceso con su duración y ejecuta primero aquellos que duran menos. Está ideado para sistemas donde predominan los trabajos batch y está orientado a maximizar el throughput.
	
	Si los procesos ejecutados tienen un comportamiento regular, se puede usa el historial de ejecución para predecir los tiempos ejecución de los procesos actuales. Sin embargo, en sistemas con proceso heterogeneos no es posible saber cuanto tiempo de ejecución va a necesitar cada uno por lo que no es posible implementar este algoritmo.

	\subsection{\red{Scheduling para tiempo real y para SMP}}
	% TODO

\section{\red{Sincronización entre procesos}}
	\subsection{\red{Contención}}
	% TODO
	\subsection{\red{Condiciones de carrera}}
	% TODO
	\subsection{\red{Secciones críticas}}
	% TODO
	\subsection{\red{TestAndSet}}
	% TODO
	\subsection{\red{Busy waiting / sleep}}
	% TODO
	\subsection{\red{Productor - Consumidor}}
	% TODO
	\subsection{\red{Semáforos}}
	% TODO
	\subsection{\red{Introducción a deadlock}}
	% TODO
	\subsection{\red{Monitores}}
	% TODO
	\subsection{\red{Variables de condición}}
	% TODO

\section{\red{Programación concurrente}}
	\subsection{\red{Algoritmos wait-free}}
	% TODO
	\subsection{\red{Algoritmos lock-free}}
	% TODO
	\subsection{\red{CAS}}
	% TODO
	\subsection{\red{ABA}}
	% TODO
	\subsection{\red{Programación de multicores}}
	% TODO
	\subsection{\red{Invalidación de caché}}
	% TODO
	\subsection{\red{Reorden de instrucciones}}
	% TODO

\section{\red{Administración de memoria}}
	\subsection{\red{Segmentación}}
	% TODO
	\subsection{\red{Paginación}}
	% TODO
	\subsection{\red{Swapping}}
	% TODO
	\subsection{\red{MMU}}
	% TODO
	\subsection{\red{Memoria virtual}}
	% TODO
	\subsection{\red{Copy-on-write}}
	% TODO
	\subsection{\red{Algoritmos de reemplazo de páginas}}
	% TODO
\section{\red{Administración de entrada/salida}}
	\subsection{\red{Polling, interrupciones, DMA}}
	% TODO
	\subsection{\red{Almacenamiento secundario}}
	% TODO
	\subsection{\red{Drivers}}
	% TODO
	\subsection{\red{Políticas de scheduling de E/S a disco}}
	% TODO
	\subsection{\red{Gestión del disco (formateo, booteo, bloques dañados)}}
	% TODO
	\subsection{\red{RAID}}
	% TODO
	\subsection{\red{Copias de seguridad}}
	% TODO
	\subsection{\red{Spooling}}
	% TODO
	\subsection{\red{Clocks}}
	% TODO

\section{\red{Sistemas de archivos}}
	\subsection{\red{Responsabilidades del FS}}
	% TODO
	\subsection{\red{Punto de montaje}}
	% TODO
	\subsection{\red{Representación de archivos}}
	% TODO
	\subsection{\red{Manejo del espacio libre}}
	% TODO
	\subsection{\red{FAT, inodos}}
	% TODO
	\subsection{\red{Atributos}}
	% TODO
	\subsection{\red{Directorios}}
	% TODO
	\subsection{\red{Caché}}
	% TODO
	\subsection{\red{Consistencia, journaling}}
	% TODO
	\subsection{\red{Características avanzadas}}
	% TODO
	\subsection{\red{NFS, VFS}}
	% TODO

\section{\red{Protección y seguridad}}
	\subsection{\red{Conceptos de protección y seguridad}}
	% TODO
	\subsection{\red{Matrices de permisos}}
	% TODO
	\subsection{\red{MAC vs. DAC}}
	% TODO
	\subsection{\red{Autenticación, autorización y auditoría}}
	% TODO
	\subsection{\red{Funciones de hash de una vía}}
	% TODO
	\subsection{\red{Encriptación simétrica}}
	% TODO
	\subsection{\red{RSA}}
	% TODO
	\subsection{\red{Privilegios de procesos}}
	% TODO
	\subsection{\red{Buffer overflows}}
	% TODO
	\subsection{\red{Inyección de parámetros}}
	% TODO
	\subsection{\red{Condiciones de carrera}}
	% TODO
	\subsection{\red{Sandboxes}}
	% TODO
	\subsection{\red{Principios generale de seguridad}}
	% TODO

\section{\red{Sistemas distribuidos}}
	\subsection{\red{Taxonomía de Flynn}}
	% TODO
	\subsection{\red{Arquitecturas de HW y SW para sistemas distribuidos}}
	% TODO
	\subsection{\red{RPC}}
	% TODO
	\subsection{\red{Threads}}
	% TODO
	\subsection{\red{Pasaje de mensajes}}
	% TODO
	\subsection{\red{Orden parcial entre eventos}}
	% TODO
	\subsection{\red{Livelock}}
	% TODO
	\subsection{\red{Acuerdo bizantino}}
	% TODO
	\subsection{\red{Intuición de safety, liveness, fairness}}
	% TODO
	\subsection{{Algoritmo del banquero}}
	% TODO
	\subsection{\red{Panadería de Lamport}}
	% TODO
	\subsection{\red{Modelos de fallas y métricas de complejidad}}

	% TODO
	\subsection{\red{Exclusión mutua y locks distribuidos}}
	% TODO
	\subsection{\red{Elección de líder}}
	% TODO
	\subsection{\red{Instantánea global consistente}}
	% TODO
	\subsection{\red{2PC}}
	% TODO

\section{\red{Conceptos avanzados}}
	\subsection{\red{Virtualización}}
	% TODO
	\subsection{\red{Contenedores}}
	% TODO
	\subsection{\red{Cloud computing}}
	% TODO
\end{document}

